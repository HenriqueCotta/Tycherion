Tycherion
├── >>> .env <<<
├── >>> .env.example <<<
├── .git (ignored)
├── .gitignore (ignored)
├── .venv (ignored)
├── README.md (ignored)
├── configs
│   └── >>> demo.yaml <<<
├── pj_output.txt (ignored)
├── >>> pyproject.toml <<<
├── >>> requirements.txt <<<
├── scripts
│   └── >>> run_demo.py <<<
├── src
│   └── tycherion
│       ├── adapters
│       │   └── mt5
│       │       ├── __pycache__ (ignored)
│       │       ├── >>> account_mt5.py <<<
│       │       ├── >>> market_data_mt5.py <<<
│       │       ├── >>> trading_mt5.py <<<
│       │       └── >>> universe_mt5.py <<<
│       ├── app
│       │   ├── __pycache__ (ignored)
│       │   └── >>> main.py <<<
│       ├── application
│       │   ├── plugins
│       │   │   ├── __pycache__ (ignored)
│       │   │   └── >>> registry.py <<<
│       │   ├── runmodes
│       │   │   ├── __pycache__ (ignored)
│       │   │   └── >>> live_multimodel.py <<<
│       │   └── services
│       │       ├── __pycache__ (ignored)
│       │       ├── >>> coverage_selector.py <<<
│       │       ├── >>> ensemble.py <<<
│       │       ├── >>> order_planner.py <<<
│       │       └── >>> sizer.py <<<
│       ├── domain
│       │   ├── >>> __init__.py <<<
│       │   ├── __pycache__ (ignored)
│       │   ├── market
│       │   │   ├── >>> __init__.py <<<
│       │   │   ├── __pycache__ (ignored)
│       │   │   └── >>> entities.py <<<
│       │   ├── portfolio
│       │   │   ├── >>> __init__.py <<<
│       │   │   ├── __pycache__ (ignored)
│       │   │   ├── allocators
│       │   │   │   ├── >>> __init__.py <<<
│       │   │   │   ├── __pycache__ (ignored)
│       │   │   │   ├── >>> equal_weight.py <<<
│       │   │   │   └── >>> proportional.py <<<
│       │   │   ├── balancers
│       │   │   │   ├── >>> __init__.py <<<
│       │   │   │   ├── __pycache__ (ignored)
│       │   │   │   └── >>> threshold.py <<<
│       │   │   └── >>> entities.py <<<
│       │   └── signals
│       │       ├── >>> __init__.py <<<
│       │       ├── __pycache__ (ignored)
│       │       ├── >>> entities.py <<<
│       │       ├── indicators
│       │       │   ├── >>> __init__.py <<<
│       │       │   ├── __pycache__ (ignored)
│       │       │   ├── >>> stretch_zscore.py <<<
│       │       │   ├── >>> trend_donchian.py <<<
│       │       │   └── >>> volatility_atr.py <<<
│       │       └── models
│       │           ├── >>> __init__.py <<<
│       │           ├── __pycache__ (ignored)
│       │           ├── >>> mean_reversion.py <<<
│       │           └── >>> trend_following.py <<<
│       ├── ports
│       │   ├── __pycache__ (ignored)
│       │   ├── >>> account.py <<<
│       │   ├── >>> market_data.py <<<
│       │   ├── >>> trading.py <<<
│       │   └── >>> universe.py <<<
│       └── shared
│           ├── __pycache__ (ignored)
│           ├── >>> config.py <<<
│           └── >>> decorators.py <<<
└── tycherion_guidelines.md (ignored)



--- .env:START ---
MT5_TERMINAL_PATH="C:\\Program Files\\MetaTrader 5 Terminal\\terminal64.exe"

# DEMO
MT5_SERVER="Rico-DEMO"
MT5_LOGIN="3008317111"
MT5_PASSWORD="BusterBD001."

# # PROD
# MT5_SERVER="Rico-PROD"
# MT5_LOGIN="3008317111"
# MT5_PASSWORD="BusterBD001."
--- .env:END ---

--- .env.example:START ---
# Opcional: se quiser logar via código em vez do Terminal já autenticado
MT5_TERMINAL_PATH=
MT5_SERVER=
MT5_LOGIN=
MT5_PASSWORD=

--- .env.example:END ---

--- pyproject.toml:START ---
[build-system]
requires = ["setuptools>=68", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "tycherion"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
  "MetaTrader5>=5.0",
  "pandas>=2.2",
  "pyyaml>=6.0",
  "python-dotenv>=1.0",
  "pydantic>=2.8",
  "typing-extensions>=4.12"
]

[tool.setuptools]
package-dir = {"" = "src"}

[tool.setuptools.packages.find]
where = ["src"]

[tool.mypy]
python_version = "3.10"
strict = true

[tool.ruff]
line-length = 100

--- pyproject.toml:END ---

--- requirements.txt:START ---
MetaTrader5>=5.0
pandas>=2.2
pyyaml>=6.0
python-dotenv>=1.0
pydantic>=2.8
typing-extensions>=4.12

--- requirements.txt:END ---

--- configs\demo.yaml:START ---
timeframe: "H1"

lookback_days: 15

trading:
  dry_run: true
  require_demo: true
  deviation_points: 10
  volume_mode: "min"
  fixed_volume: 100.0

risk:
  risk_per_trade_pct: 0.5
  max_daily_loss_pct: 2.0

mt5:
  terminal_path: null
  server: null
  login: null
  password: null

application:
  run_mode:
    name: "live_multimodel"
  playbook: "default"
  schedule:
    run_forever: true
    interval_seconds: 60

  coverage:
    source: "static"
    symbols: ["PETR4", "VALE3", "WIN$", "WDO$"]
    pattern: null

  models:
    pipeline:
      - "trend_following"
      - "mean_reversion"

  portfolio:
    allocator: "proportional"
    balancer: "threshold"
    threshold_weight: 0.25

--- configs\demo.yaml:END ---

--- scripts\run_demo.py:START ---
import sys, pathlib
ROOT = pathlib.Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT / "src"))
from tycherion.app.main import run_app
if __name__ == "__main__":
    run_app(config_path=str(ROOT / "configs" / "demo.yaml"))

--- scripts\run_demo.py:END ---

--- src\tycherion\adapters\mt5\account_mt5.py:START ---
from __future__ import annotations

import MetaTrader5 as mt5

from tycherion.ports.account import AccountPort
from tycherion.domain.portfolio.entities import Position


class MT5Account(AccountPort):
    def is_demo(self) -> bool:
        ai = mt5.account_info()
        return bool(ai and ai.trade_mode == mt5.ACCOUNT_TRADE_MODE_DEMO)

    def balance(self) -> float:
        ai = mt5.account_info()
        return float(getattr(ai, "balance", 0.0) or 0.0)

    def equity(self) -> float:
        ai = mt5.account_info()
        return float(getattr(ai, "equity", 0.0) or 0.0)

    def positions(self) -> list[Position]:
        poss = mt5.positions_get()
        out: list[Position] = []
        if poss:
            for p in poss:
                out.append(
                    Position(
                        symbol=p.symbol,
                        quantity=float(getattr(p, "volume", 0.0) or 0.0),
                        price=float(getattr(p, "price_open", 0.0) or 0.0),
                    )
                )
        return out

--- src\tycherion\adapters\mt5\account_mt5.py:END ---

--- src\tycherion\adapters\mt5\market_data_mt5.py:START ---
from __future__ import annotations
from datetime import datetime, timezone
from typing import Dict
import pandas as pd
import MetaTrader5 as mt5
from tycherion.ports.market_data import MarketDataPort

_TF_MAP: Dict[str, int] = {
    "M1": mt5.TIMEFRAME_M1,
    "M5": mt5.TIMEFRAME_M5,
    "M15": mt5.TIMEFRAME_M15,
    "M30": mt5.TIMEFRAME_M30,
    "H1": mt5.TIMEFRAME_H1,
    "H4": mt5.TIMEFRAME_H4,
    "D1": mt5.TIMEFRAME_D1,
}

class MT5MarketData(MarketDataPort):
    def get_bars(self, symbol: str, timeframe: str, start: datetime, end: datetime) -> pd.DataFrame:
        tf = _TF_MAP.get(timeframe.upper())
        if tf is None:
            raise ValueError(f"Unsupported timeframe: {timeframe}")
        rates = mt5.copy_rates_range(
            symbol, tf,
            start.astimezone(timezone.utc),
            end.astimezone(timezone.utc)
        )
        if rates is None or len(rates) == 0:
            return pd.DataFrame(columns=["time","open","high","low","close","tick_volume","spread","real_volume"])
        df = pd.DataFrame(rates)
        df["time"] = pd.to_datetime(df["time"], unit="s", utc=True)
        return df
--- src\tycherion\adapters\mt5\market_data_mt5.py:END ---

--- src\tycherion\adapters\mt5\trading_mt5.py:START ---
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
import MetaTrader5 as mt5
from tycherion.ports.trading import TradingPort, TradeResult
from tycherion.shared.decorators import demo_only, logged
from tycherion.application.services.sizer import symbol_min_volume, volume_from_weight

@dataclass
class MT5Trader(TradingPort):
    dry_run: bool = True
    require_demo: bool = True
    deviation_points: int = 10
    volume_mode: str = "min"
    fixed_volume: float = 0.01

    def _resolve_volume(self, symbol: str, volume: Optional[float]) -> float:
        if volume is not None:
            return float(volume)
        return volume_from_weight(symbol, 1.0, self.volume_mode, self.fixed_volume)

    @logged
    @demo_only
    def market_buy(self, symbol: str, volume: Optional[float] = None) -> TradeResult:
        if self.dry_run:
            return TradeResult(True, 0, None, "DRY_RUN: buy skipped")
        if not mt5.symbol_select(symbol, True):
            return TradeResult(False, -1, None, f"symbol_select failed: {symbol}")
        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            return TradeResult(False, -2, None, "missing tick")
        vol = self._resolve_volume(symbol, volume)
        if vol < symbol_min_volume(symbol):
            vol = symbol_min_volume(symbol)
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "type": mt5.ORDER_TYPE_BUY,
            "volume": vol,
            "price": tick.ask,
            "deviation": self.deviation_points,
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_RETURN,
            "magic": 401,
            "comment": "tycherion-buy",
        }
        check = mt5.order_check(request)
        if not check or check.retcode != mt5.TRADE_RETCODE_DONE:
            return TradeResult(False, getattr(check, "retcode", -3), None, f"order_check failed: {check}")
        res = mt5.order_send(request)
        ok = bool(res and res.retcode in (mt5.TRADE_RETCODE_DONE, mt5.TRADE_RETCODE_PLACED))
        return TradeResult(ok, getattr(res, "retcode", -4), getattr(res, "order", None), str(res))

    @logged
    @demo_only
    def market_sell(self, symbol: str, volume: Optional[float] = None) -> TradeResult:
        if self.dry_run:
            return TradeResult(True, 0, None, "DRY_RUN: sell skipped")
        if not mt5.symbol_select(symbol, True):
            return TradeResult(False, -1, None, f"symbol_select failed: {symbol}")
        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            return TradeResult(False, -2, None, "missing tick")
        vol = self._resolve_volume(symbol, volume)
        if vol < symbol_min_volume(symbol):
            vol = symbol_min_volume(symbol)
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "type": mt5.ORDER_TYPE_SELL,
            "volume": vol,
            "price": tick.bid,
            "deviation": self.deviation_points,
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_RETURN,
            "magic": 401,
            "comment": "tycherion-sell",
        }
        check = mt5.order_check(request)
        if not check or check.retcode != mt5.TRADE_RETCODE_DONE:
            return TradeResult(False, getattr(check, "retcode", -3), None, f"order_check failed: {check}")
        res = mt5.order_send(request)
        ok = bool(res and res.retcode in (mt5.TRADE_RETCODE_DONE, mt5.TRADE_RETCODE_PLACED))
        return TradeResult(ok, getattr(res, "retcode", -4), getattr(res, "order", None), str(res))

--- src\tycherion\adapters\mt5\trading_mt5.py:END ---

--- src\tycherion\adapters\mt5\universe_mt5.py:START ---
from __future__ import annotations
import MetaTrader5 as mt5
from typing import List
from tycherion.ports.universe import UniversePort

class MT5Universe(UniversePort):
    def visible_symbols(self) -> List[str]:
        syms = mt5.symbols_get()
        return [s.name for s in syms if getattr(s, "visible", False)]

    def by_pattern(self, pattern: str) -> List[str]:
        syms = mt5.symbols_get(pattern)
        return [s.name for s in syms]

--- src\tycherion\adapters\mt5\universe_mt5.py:END ---

--- src\tycherion\app\main.py:START ---
from __future__ import annotations

import MetaTrader5 as mt5

from tycherion.shared.config import load_config, AppConfig
from tycherion.adapters.mt5.market_data_mt5 import MT5MarketData
from tycherion.adapters.mt5.trading_mt5 import MT5Trader
from tycherion.adapters.mt5.account_mt5 import MT5Account
from tycherion.adapters.mt5.universe_mt5 import MT5Universe
from tycherion.application.runmodes.live_multimodel import run_live_multimodel
from tycherion.application.plugins import registry as _registry


def _ensure_initialized(cfg: AppConfig) -> None:
    if not mt5.initialize(path=cfg.mt5.terminal_path or None):
        raise SystemExit(f"MT5 initialize failed: {mt5.last_error()}")
    if cfg.mt5.login and cfg.mt5.password and cfg.mt5.server:
        if not mt5.login(
            login=int(cfg.mt5.login),
            password=cfg.mt5.password,
            server=cfg.mt5.server,
        ):
            raise SystemExit(f"MT5 login failed: {mt5.last_error()}")


def run_app(config_path: str) -> None:
    cfg = load_config(config_path)

    # Discover all indicators, models, allocators and balancers
    _registry.auto_discover()

    _ensure_initialized(cfg)
    try:
        market_data = MT5MarketData()
        trader = MT5Trader(
            dry_run=cfg.trading.dry_run,
            require_demo=cfg.trading.require_demo,
            deviation_points=cfg.trading.deviation_points,
            volume_mode=cfg.trading.volume_mode,
            fixed_volume=cfg.trading.fixed_volume,
        )
        account = MT5Account()
        universe = MT5Universe()

        run_mode = (cfg.application.run_mode.name or "").lower()
        if run_mode == "live_multimodel":
            run_live_multimodel(cfg, market_data, trader, account, universe)
        else:
            raise SystemExit(f"Unknown run_mode: {run_mode}")
    finally:
        mt5.shutdown()

--- src\tycherion\app\main.py:END ---

--- src\tycherion\application\plugins\registry.py:START ---
from __future__ import annotations
from typing import Dict, List, Callable, Iterable

INDICATORS: Dict[str, List[object]] = {}
MODELS: Dict[str, object] = {}
ALLOCATORS: Dict[str, object] = {}
BALANCERS: Dict[str, object] = {}
DEFAULT_METHOD: Dict[str, str] = {}


def register_indicator(*, key: str, method: str, tags: set[str]):
    """
    Register an indicator implementation for a given logical key (e.g. "trend")
    and method (e.g. "donchian_50_50").
    """
    def deco(cls):
        inst = cls()
        inst.key = key
        inst.method = method
        inst.tags = tags
        INDICATORS.setdefault(key, []).append(inst)
        return cls
    return deco


def register_model(*, name: str, tags: set[str]):
    """
    Register a per-symbol signal model.
    """
    def deco(cls):
        inst = cls()
        inst.name = name
        inst.tags = tags
        MODELS[name] = inst
        return cls
    return deco


def register_allocator(*, name: str, tags: set[str]):
    """
    Register a portfolio allocator strategy.
    """
    def deco(cls):
        inst = cls()
        inst.name = name
        inst.tags = tags
        ALLOCATORS[name] = inst
        return cls
    return deco


def register_balancer(*, name: str, tags: set[str]):
    """
    Register a portfolio balancer / rebalancer strategy.
    """
    def deco(cls):
        inst = cls()
        inst.name = name
        inst.tags = tags
        BALANCERS[name] = inst
        return cls
    return deco


def set_default_indicator_method(key: str, method: str) -> None:
    DEFAULT_METHOD[key] = method


def pick_indicator_for(key: str, playbook: str | None = None):
    """
    Pick an indicator instance for a given key and (optionally) playbook.
    Preference order:
    - indicators whose tags contain the playbook name
    - indicators whose tags contain "default"
    - otherwise, the first registered
    If DEFAULT_METHOD[key] is set, prefer that method among candidates.
    """
    candidates: Iterable[object] = INDICATORS.get(key, [])
    candidates = list(candidates)
    if not candidates:
        raise KeyError(f"No indicators registered for key={key!r}")

    # filter by tags / playbook
    if playbook:
        tagged = [
            ind for ind in candidates
            if playbook in getattr(ind, "tags", set())
        ]
        if tagged:
            candidates = tagged

    # then prefer "default"
    defaults = [
        ind for ind in candidates
        if "default" in getattr(ind, "tags", set())
    ]
    if defaults:
        candidates = defaults

    # lastly, prefer DEFAULT_METHOD if configured
    method = DEFAULT_METHOD.get(key)
    if method:
        for ind in candidates:
            if getattr(ind, "method", None) == method:
                return ind

    return candidates[0]


def auto_discover() -> None:
    """
    Import all plugin modules so that their decorators run and fill the
    registries above. This is called once during application startup.
    """
    import importlib
    import pkgutil

    bases = (
        "tycherion.domain.signals.indicators",
        "tycherion.domain.signals.models",
        "tycherion.domain.portfolio.allocators",
        "tycherion.domain.portfolio.balancers",
    )

    for base in bases:
        try:
            pkg = importlib.import_module(base)
        except Exception as e:
            print(f"[plugins] base import failed: {base} -> {e}")
            continue

        pkg_path = getattr(pkg, "__path__", None)
        if not pkg_path:
            continue

        for mod in pkgutil.walk_packages(pkg_path, pkg.__name__ + "."):
            try:
                importlib.import_module(mod.name)
            except Exception as e:
                print(f"[plugins] import failed: {mod.name} -> {e}")

    print(
        f"[plugins] discovered "
        f"indicators={sum(len(v) for v in INDICATORS.values())} "
        f"models={len(MODELS)} "
        f"allocators={len(ALLOCATORS)} "
        f"balancers={len(BALANCERS)}"
    )

--- src\tycherion\application\plugins\registry.py:END ---

--- src\tycherion\application\runmodes\live_multimodel.py:START ---
from __future__ import annotations

import time
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Tuple

from tycherion.shared.config import AppConfig, PipelineStageCfg
from tycherion.ports.market_data import MarketDataPort
from tycherion.ports.trading import TradingPort
from tycherion.ports.account import AccountPort
from tycherion.ports.universe import UniversePort
from tycherion.application.plugins.registry import (
    MODELS,
    ALLOCATORS,
    BALANCERS,
    pick_indicator_for,
)
from tycherion.application.services.coverage_selector import build_coverage
from tycherion.application.services.ensemble import combine
from tycherion.application.services.order_planner import build_orders
from tycherion.domain.portfolio.entities import (
    Signal,
    SignalsBySymbol,
    PortfolioSnapshot,
    Position,
)
from tycherion.domain.signals.entities import (
    IndicatorOutput,
    ModelDecision,
    SymbolState,
    ModelStageResult,
)


def _build_portfolio_snapshot(account: AccountPort) -> PortfolioSnapshot:
    equity = float(account.equity())
    positions: Dict[str, Position] = {}
    for p in account.positions():
        positions[p.symbol] = p
    return PortfolioSnapshot(equity=equity, positions=positions)


def _decision_to_score(d: ModelDecision) -> float:
    """Map a ModelDecision into a numeric score in [-1, 1]."""
    side = (d.side or "HOLD").upper()
    w = float(d.weight or 0.0)
    w = max(0.0, min(1.0, w))
    if side == "BUY":
        s = w
    elif side == "SELL":
        s = -w
    else:
        s = 0.0
    return max(-1.0, min(1.0, s))


def _resolve_pipeline(cfg: AppConfig) -> List[Tuple[PipelineStageCfg, object]]:
    stages = list(cfg.application.models.pipeline or [])
    if not stages:
        raise RuntimeError(
            "No model pipeline configured. Please set application.models.pipeline in your YAML."
        )

    pipeline: List[Tuple[PipelineStageCfg, object]] = []
    for stage in stages:
        name = stage.name
        model = MODELS.get(name)
        if not model:
            available = ", ".join(sorted(MODELS.keys()))
            raise RuntimeError(f"Model not found: {name!r}. Available models: {available}")
        pipeline.append((stage, model))
    return pipeline


def run_live_multimodel(
    cfg: AppConfig,
    data: MarketDataPort,
    trader: TradingPort,
    account: AccountPort,
    universe: UniversePort,
) -> None:
    """Live runmode executing an ordered model pipeline per symbol."""
    playbook = cfg.application.playbook or "default"

    allocator = ALLOCATORS.get(cfg.application.portfolio.allocator)
    if not allocator:
        raise RuntimeError(f"Allocator not found: {cfg.application.portfolio.allocator!r}")

    balancer = BALANCERS.get(cfg.application.portfolio.balancer)
    if not balancer:
        raise RuntimeError(f"Balancer not found: {cfg.application.portfolio.balancer!r}")

    pipeline = _resolve_pipeline(cfg)
    print(f"[models] pipeline={[stage.name for stage, _ in pipeline]}")
    print(f"[plugins] available_models={len(MODELS)}")

    def step_once() -> None:
        # 1) Structural symbol universe from coverage + ensure held symbols are included
        coverage = build_coverage(cfg, data, universe)
        current_positions = account.positions()
        held_symbols = {p.symbol for p in current_positions}
        coverage = sorted(set(coverage) | held_symbols)
        print(f"[coverage] {len(coverage)} symbols -> {coverage}")

        # 2) Initialise per-symbol state
        states: Dict[str, SymbolState] = {
            sym: SymbolState(symbol=sym, is_held=(sym in held_symbols))
            for sym in coverage
        }

        # 3) Portfolio snapshot (before new trades)
        portfolio = _build_portfolio_snapshot(account)

        # 4) Time window for analysis
        end = datetime.now(timezone.utc)
        start = end - timedelta(days=cfg.lookback_days)

        # 5) Determine which indicators we need for the whole pipeline
        needed_keys: set[str] = set()
        for _, model in pipeline:
            try:
                needed_keys.update(model.requires() or set())
            except Exception:
                pass
        print(f"[indicators] needed_keys={sorted(needed_keys)}")

        # 6) Per-symbol model pipeline
        for symbol, state in states.items():
            if not state.alive and not state.is_held:
                continue

            try:
                df = data.get_bars(symbol, cfg.timeframe, start, end)
            except Exception as e:
                print(f"[{symbol}] data error: {e}")
                state.notes["data_error"] = 1.0
                if not state.is_held:
                    state.alive = False
                continue

            if df is None or df.empty:
                print(f"[{symbol}] no data.")
                state.notes["no_data"] = 1.0
                if not state.is_held:
                    state.alive = False
                continue

            # Compute indicators once and share across models
            bundle: Dict[str, IndicatorOutput] = {}
            for key in needed_keys:
                ind = pick_indicator_for(key, playbook)
                try:
                    bundle[key] = ind.compute(df.copy())
                except Exception as e:
                    print(f"[{symbol}] indicator {key}:{getattr(ind, 'method', '?')} failed: {e}")
                    bundle[key] = IndicatorOutput(score=0.0, features={})

            stage_decisions: list[ModelDecision] = []

            for stage_cfg, model in pipeline:
                if not state.alive and not state.is_held:
                    break

                stage_name = stage_cfg.name
                try:
                    decision: ModelDecision = model.decide(bundle)
                except Exception as e:
                    print(f"[{symbol}] model {stage_name} failed: {e}")
                    decision = ModelDecision(side="HOLD", weight=0.0, confidence=0.0)
                    state.notes[f"model_error_{stage_name}"] = 1.0

                stage_decisions.append(decision)

                score = _decision_to_score(decision)
                state.pipeline_results.append(
                    ModelStageResult(model_name=stage_name, score=score)
                )

                threshold = (
                    float(stage_cfg.drop_threshold)
                    if stage_cfg.drop_threshold is not None
                    else float(getattr(model, "drop_threshold", -1.0))
                )

                if score < threshold:
                    if state.is_held:
                        # Held symbols are never silently discarded. Keep going, but record the fact.
                        state.notes[f"below_threshold_{stage_name}"] = 1.0
                    else:
                        state.alive = False
                        state.notes[f"dropped_by_{stage_name}"] = 1.0
                        break

            agg = combine(stage_decisions)
            state.alpha_score = float(agg.signed)
            state.notes["final_confidence"] = float(agg.confidence)
            state.notes["final_side"] = 1.0 if agg.side == "BUY" else (-1.0 if agg.side == "SELL" else 0.0)

        # 7) Convert states into SignalsBySymbol for the allocator
        signals: SignalsBySymbol = {}
        for symbol, state in states.items():
            if not state.alive and not state.is_held:
                continue
            signed = float(state.alpha_score)
            confidence = float(state.notes.get("final_confidence", 1.0))
            signals[symbol] = Signal(symbol=symbol, signed=signed, confidence=confidence)

        # 8) Allocation -> target weights
        target_alloc = allocator.allocate(signals)

        # 9) Balancing -> rebalance plan
        plan = balancer.plan(
            portfolio=portfolio,
            target=target_alloc,
            threshold=cfg.application.portfolio.threshold_weight,
        )
        print(f"[rebalance] plan={len(plan)} instructions")

        # 10) Orders -> execution
        orders = build_orders(portfolio, plan, cfg.trading)
        print(f"[orders] {len(orders)} orders to execute")

        for od in orders:
            if od.side.upper() == "BUY":
                res = trader.market_buy(od.symbol, volume=od.volume)
            else:
                res = trader.market_sell(od.symbol, volume=od.volume)
            print(f"[trade] {od.side} {od.symbol} vol={od.volume} -> {res}")

    if cfg.application.schedule.run_forever:
        while True:
            try:
                step_once()
                time.sleep(max(1, cfg.application.schedule.interval_seconds))
            except KeyboardInterrupt:
                print("Stopping by keyboard.")
                break
            except Exception as e:
                print("Loop error:", e)
                time.sleep(3)
    else:
        step_once()

--- src\tycherion\application\runmodes\live_multimodel.py:END ---

--- src\tycherion\application\services\coverage_selector.py:START ---
from __future__ import annotations

from tycherion.shared.config import AppConfig
from tycherion.ports.market_data import MarketDataPort
from tycherion.ports.universe import UniversePort


def _build_base_coverage(cfg: AppConfig, universe: UniversePort) -> list[str]:
    """Build the *structural* universe of symbols.

    Coverage is intentionally dumb. It only answers: *which* symbols should be
    considered, based on the configured source. Any kind of "smart filtering"
    (liquidity, regimes, sanity checks, alpha, etc.) must live in the model
    pipeline, not here.
    """
    src = (cfg.application.coverage.source or "").lower()
    if src == "static":
        # Remove duplicates while preserving order
        return list(dict.fromkeys(cfg.application.coverage.symbols or []))
    if src == "market_watch":
        return universe.visible_symbols()
    if src == "pattern":
        patt = cfg.application.coverage.pattern or "*"
        return universe.by_pattern(patt)
    return universe.visible_symbols()


def build_coverage(cfg: AppConfig, data: MarketDataPort, universe: UniversePort) -> list[str]:
    """Build the list of symbols to analyse in this run.

    NOTE: `data` is kept in the signature for backward compatibility, but is
    intentionally unused. The universe thinning that previously depended on
    recent `tick_volume` (coverage.top_n) is deprecated and removed.
    """
    _ = data  # explicit unused
    return _build_base_coverage(cfg, universe)

--- src\tycherion\application\services\coverage_selector.py:END ---

--- src\tycherion\application\services\ensemble.py:START ---
# application/services/ensemble.py (versão nova)

from __future__ import annotations

from typing import List
from tycherion.domain.signals.entities import ModelDecision, AggregatedDecision


def combine(decisions: List[ModelDecision]) -> AggregatedDecision:
    """
    Combina uma lista de ModelDecision em uma decisão agregada única.
    """
    if not decisions:
        return AggregatedDecision(
            side="HOLD",
            weight=0.0,
            confidence=0.0,
            signed=0.0,
        )

    num, den = 0.0, 0.0
    for d in decisions:
        side = (d.side or "HOLD").upper()
        w = float(d.weight)
        c = float(d.confidence if d.confidence is not None else 0.5)
        c = max(0.0, min(1.0, c))

        if side == "BUY":
            signed = w
        elif side == "SELL":
            signed = -w
        else:
            signed = 0.0

        num += signed * c
        den += c

    if den <= 0:
        return AggregatedDecision(
            side="HOLD",
            weight=0.0,
            confidence=0.0,
            signed=0.0,
        )

    s = num / den
    side = "BUY" if s > 0.1 else ("SELL" if s < -0.1 else "HOLD")
    weight = min(1.0, abs(s))
    confidence = min(1.0, den / max(1, len(decisions)))

    return AggregatedDecision(
        side=side,
        weight=weight,
        confidence=confidence,
        signed=s,
    )

--- src\tycherion\application\services\ensemble.py:END ---

--- src\tycherion\application\services\order_planner.py:START ---
from __future__ import annotations

from dataclasses import dataclass
from typing import List

from tycherion.domain.portfolio.entities import PortfolioSnapshot, RebalanceInstruction
from tycherion.shared.config import Trading


@dataclass
class SuggestedOrder:
    symbol: str
    side: str   # "BUY" | "SELL"
    volume: float


def build_orders(
    portfolio: PortfolioSnapshot,
    plan: List[RebalanceInstruction],
    trading_cfg: Trading,
) -> List[SuggestedOrder]:
    """
    Convert domain-level rebalance instructions (expressed in weights) into
    concrete order suggestions with broker volumes. This is the point where
    we cross from the pure portfolio domain into broker-specific constraints.
    """
    # Lazy import to avoid circular deps
    from tycherion.application.services.sizer import (
        volume_from_weight,
        symbol_min_volume,
    )

    orders: List[SuggestedOrder] = []
    for instr in plan:
        # For now we scale volumes solely by absolute delta_weight. In the
        # future this can incorporate volatility, risk, etc.
        w = abs(float(instr.delta_weight))
        if w <= 0.0:
            continue

        vol = volume_from_weight(
            instr.symbol,
            w,
            trading_cfg.volume_mode,
            trading_cfg.fixed_volume,
        )
        min_vol = symbol_min_volume(instr.symbol)
        vol = max(vol, min_vol)
        if vol <= 0.0:
            continue

        orders.append(
            SuggestedOrder(
                symbol=instr.symbol,
                side=instr.side,
                volume=vol,
            )
        )
    return orders

--- src\tycherion\application\services\order_planner.py:END ---

--- src\tycherion\application\services\sizer.py:START ---
from __future__ import annotations
import MetaTrader5 as mt5

def symbol_min_volume(symbol: str) -> float:
    info = mt5.symbol_info(symbol)
    if not info:
        return 0.0
    v = max(info.volume_min, info.volume_step)
    steps = round(v / info.volume_step)
    return steps * info.volume_step

def volume_from_weight(symbol: str, weight: float, mode: str, fixed_volume: float) -> float:
    weight = max(0.0, min(1.0, float(weight)))
    if weight < 1e-6:
        return 0.0
    if mode == 'fixed':
        return float(fixed_volume) * weight
    return symbol_min_volume(symbol)

--- src\tycherion\application\services\sizer.py:END ---

--- src\tycherion\domain\__init__.py:START ---


--- src\tycherion\domain\__init__.py:END ---

--- src\tycherion\domain\market\entities.py:START ---
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import NewType

Symbol = NewType("Symbol", str)


class AssetClass(str, Enum):
    EQUITY = "equity"
    FUTURE = "future"
    FX = "fx"
    OTHER = "other"


@dataclass
class Instrument:
    """Domain representation of a tradable instrument (stock, future, FX, etc.)."""

    symbol: Symbol
    asset_class: AssetClass
    currency: str
    lot_size: float
    min_volume: float
    volume_step: float


@dataclass
class Bar:
    """Minimal OHLCV bar used by indicators and models when not using DataFrame."""

    symbol: Symbol
    time: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float

--- src\tycherion\domain\market\entities.py:END ---

--- src\tycherion\domain\market\__init__.py:START ---


--- src\tycherion\domain\market\__init__.py:END ---

--- src\tycherion\domain\portfolio\entities.py:START ---
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict


Symbol = str


@dataclass
class Signal:
    """Per-symbol signal produced by the models/ensemble.

    signed: desired direction/intensity in [-1, 1]
    confidence: optional confidence level in [0, 1]
    """

    symbol: Symbol
    signed: float
    confidence: float = 1.0


SignalsBySymbol = Dict[Symbol, Signal]


@dataclass
class Position:
    """Domain-level position in a single instrument.

    quantity: number of shares/contracts/etc.
    price: best available price estimate (e.g. last close or avg price).
    """

    symbol: Symbol
    quantity: float
    price: float


@dataclass
class PortfolioSnapshot:
    """Portfolio snapshot used by allocators/balancers at the domain level.

    Equity is the current account equity in account currency.
    """

    equity: float
    positions: Dict[Symbol, Position]

    def weight_of(self, symbol: Symbol) -> float:
        pos = self.positions.get(symbol)
        if not pos or self.equity <= 0:
            return 0.0
        return float(pos.quantity * pos.price) / float(self.equity)


@dataclass
class TargetAllocation:
    """Target portfolio allocation expressed as weights per symbol in [-1, 1].

    Positive weights are long exposure, negative weights are short exposure.
    """

    weights: Dict[Symbol, float]


@dataclass
class RebalanceInstruction:
    """Domain-level rebalance instruction expressed in weights, not broker
    volumes. Conversion to concrete order sizes happens in the application
    layer (order planner).
    """

    symbol: Symbol
    from_weight: float
    to_weight: float
    delta_weight: float
    side: str  # "BUY" | "SELL"

--- src\tycherion\domain\portfolio\entities.py:END ---

--- src\tycherion\domain\portfolio\__init__.py:START ---


--- src\tycherion\domain\portfolio\__init__.py:END ---

--- src\tycherion\domain\portfolio\allocators\equal_weight.py:START ---
from __future__ import annotations

from tycherion.application.plugins.registry import register_allocator
from tycherion.domain.portfolio.entities import SignalsBySymbol, TargetAllocation


@register_allocator(name="equal_weight", tags={"default"})
class EqualWeightAllocator:
    """
    Simple allocator: gives the same absolute weight to all symbols that have
    a non-zero signal. Longs get +w, shorts get -w, holds get 0.
    """
    def allocate(self, signals: SignalsBySymbol) -> TargetAllocation:
        nonzero = [s for s in signals.values() if abs(float(s.signed)) > 1e-6]
        if not nonzero:
            # nothing to do
            return TargetAllocation(weights={})

        w = 1.0 / float(len(nonzero))
        weights: dict[str, float] = {}
        for sig in signals.values():
            if sig.signed > 0:
                weights[sig.symbol] = w
            elif sig.signed < 0:
                weights[sig.symbol] = -w
            else:
                weights[sig.symbol] = 0.0
        return TargetAllocation(weights=weights)

--- src\tycherion\domain\portfolio\allocators\equal_weight.py:END ---

--- src\tycherion\domain\portfolio\allocators\proportional.py:START ---
from __future__ import annotations

from tycherion.application.plugins.registry import register_allocator
from tycherion.domain.portfolio.entities import SignalsBySymbol, TargetAllocation


@register_allocator(name="proportional", tags={"default"})
class ProportionalAllocator:
    """
    Allocator that gives each symbol a weight proportional to the absolute
    value of its signal. Signals are normalised so that the sum of absolute
    weights is 1. Longs get +w, shorts get -w.
    """
    def allocate(self, signals: SignalsBySymbol) -> TargetAllocation:
        total = sum(abs(float(s.signed)) for s in signals.values())
        if total <= 1e-9:
            return TargetAllocation(weights={})

        weights: dict[str, float] = {}
        for sig in signals.values():
            if sig.signed == 0:
                weights[sig.symbol] = 0.0
            else:
                frac = abs(float(sig.signed)) / total
                weights[sig.symbol] = frac if sig.signed > 0 else -frac
        return TargetAllocation(weights=weights)

--- src\tycherion\domain\portfolio\allocators\proportional.py:END ---

--- src\tycherion\domain\portfolio\allocators\__init__.py:START ---


--- src\tycherion\domain\portfolio\allocators\__init__.py:END ---

--- src\tycherion\domain\portfolio\balancers\threshold.py:START ---
from __future__ import annotations

from tycherion.application.plugins.registry import register_balancer
from tycherion.domain.portfolio.entities import (
    PortfolioSnapshot,
    TargetAllocation,
    RebalanceInstruction,
)


@register_balancer(name="threshold", tags={"default"})
class ThresholdBalancer:
    """
    Domain-level balancer: generates rebalance instructions whenever the
    difference between current and target weight is greater than or equal
    to a configured threshold.
    """
    def plan(
        self,
        portfolio: PortfolioSnapshot,
        target: TargetAllocation,
        threshold: float = 0.25,
    ) -> list[RebalanceInstruction]:
        threshold = max(0.0, min(1.0, float(threshold)))
        instructions: list[RebalanceInstruction] = []

        symbols = set(target.weights.keys()) | set(portfolio.positions.keys())
        for sym in sorted(symbols):
            current_w = float(portfolio.weight_of(sym))
            target_w = float(target.weights.get(sym, 0.0))
            delta = target_w - current_w
            if abs(delta) < threshold:
                continue
            side = "BUY" if delta > 0 else "SELL"
            instructions.append(
                RebalanceInstruction(
                    symbol=sym,
                    from_weight=current_w,
                    to_weight=target_w,
                    delta_weight=delta,
                    side=side,
                )
            )
        return instructions

--- src\tycherion\domain\portfolio\balancers\threshold.py:END ---

--- src\tycherion\domain\portfolio\balancers\__init__.py:START ---


--- src\tycherion\domain\portfolio\balancers\__init__.py:END ---

--- src\tycherion\domain\signals\entities.py:START ---
from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List


@dataclass
class IndicatorOutput:
    """Standard output of an indicator for a single symbol.

    - score: aggregated metric in [-1, 1] (by convention in this project)
    - features: extra numeric features that models may consume.
    """

    score: float
    features: Dict[str, float]


@dataclass
class ModelDecision:
    """Per-model decision for a single symbol.

    side: "BUY" | "SELL" | "HOLD"
    weight: relative intensity (usually in [0, 1])
    confidence: confidence level in [0, 1]
    """

    side: str
    weight: float
    confidence: float

@dataclass
class AggregatedDecision:
    """
    Decisão agregada (ensemble) de todos os models para um símbolo.

    side       -> direção final ("BUY"/"SELL"/"HOLD")
    weight     -> intensidade em [0, 1]
    confidence -> confiança em [0, 1]
    signed     -> direção * intensidade em [-1, 1]
    """
    side: str
    weight: float
    confidence: float
    signed: float


@dataclass
class ModelStageResult:
    """Result for a symbol at a specific model stage in the pipeline."""

    model_name: str
    score: float


@dataclass
class SymbolState:
    """Mutable per-symbol state that flows through the analysis pipeline.

    This is intentionally generic so we can reuse it for universe filters,
    macro models and per-symbol alpha models over time.
    """
    symbol: str
    is_held: bool = False      # True if the symbol is currently in the portfolio
    alive: bool = True         # If False and not held, the symbol can be dropped from the pipeline

    base_score: float = 0.0    # Optional starting score (e.g. from simple filters)
    sanity_score: float = 0.0  # Data-quality / tradability / liquidity score
    macro_score: float = 0.0   # Macro / regime score for this symbol
    alpha_score: float = 0.0   # Final alpha-like score, typically coming from signal models

    pipeline_results: List[ModelStageResult] = field(default_factory=list)

    notes: Dict[str, float] = field(default_factory=dict)

--- src\tycherion\domain\signals\entities.py:END ---

--- src\tycherion\domain\signals\__init__.py:START ---


--- src\tycherion\domain\signals\__init__.py:END ---

--- src\tycherion\domain\signals\indicators\stretch_zscore.py:START ---
from __future__ import annotations

import pandas as pd

from tycherion.application.plugins.registry import register_indicator
from tycherion.domain.signals.entities import IndicatorOutput


@register_indicator(key="stretch", method="zscore_20", tags={"default"})
class StretchZScore20:
    period = 20

    def compute(self, df: pd.DataFrame) -> IndicatorOutput:
        if df.empty or len(df) < self.period:
            return IndicatorOutput(score=0.0, features={})
        close = df["close"].astype(float)
        ma = close.rolling(self.period).mean()
        sd = close.rolling(self.period).std(ddof=0).replace(0, 1e-9)
        z = (close - ma) / sd
        zval = float(z.iloc[-1])
        score = max(-1.0, min(1.0, -zval / 3.0))
        return IndicatorOutput(score=score, features={"z": zval})

--- src\tycherion\domain\signals\indicators\stretch_zscore.py:END ---

--- src\tycherion\domain\signals\indicators\trend_donchian.py:START ---
from __future__ import annotations

import pandas as pd

from tycherion.application.plugins.registry import register_indicator
from tycherion.domain.signals.entities import IndicatorOutput


@register_indicator(key="trend", method="donchian_50_50", tags={"default"})
class TrendDonchian5050:
    high_n = 50
    low_n = 50

    def compute(self, df: pd.DataFrame) -> IndicatorOutput:
        if df.empty or len(df) < max(self.high_n, self.low_n):
            return IndicatorOutput(score=0.0, features={})
        hh = df["high"].rolling(self.high_n).max()
        ll = df["low"].rolling(self.low_n).min()
        mid = (hh + ll) / 2.0
        rng = (hh - ll).replace(0, 1e-9)
        pos = (df["close"] - mid) / (rng / 2.0)
        score = float(pos.iloc[-1])
        score = max(-1.0, min(1.0, score))
        return IndicatorOutput(
            score=score,
            features={"upper": float(hh.iloc[-1]), "lower": float(ll.iloc[-1])},
        )

--- src\tycherion\domain\signals\indicators\trend_donchian.py:END ---

--- src\tycherion\domain\signals\indicators\volatility_atr.py:START ---
from __future__ import annotations

import pandas as pd

from tycherion.application.plugins.registry import register_indicator
from tycherion.domain.signals.entities import IndicatorOutput


@register_indicator(key="volatility", method="atr_14", tags={"default"})
class VolATR14:
    period = 14

    def compute(self, df: pd.DataFrame) -> IndicatorOutput:
        if df.empty or len(df) < self.period + 1:
            return IndicatorOutput(score=0.0, features={})
        high = df["high"].astype(float)
        low = df["low"].astype(float)
        close = df["close"].astype(float)
        prev_close = close.shift(1)
        tr = (high - low).abs()
        tr = pd.concat(
            [tr, (high - prev_close).abs(), (low - prev_close).abs()], axis=1
        ).max(axis=1)
        atr = tr.rolling(self.period).mean()
        val = float(atr.iloc[-1])
        score = 1.0 / (1.0 + val) if val > 0 else 0.0
        return IndicatorOutput(score=score, features={"atr": val})

--- src\tycherion\domain\signals\indicators\volatility_atr.py:END ---

--- src\tycherion\domain\signals\indicators\__init__.py:START ---


--- src\tycherion\domain\signals\indicators\__init__.py:END ---

--- src\tycherion\domain\signals\models\mean_reversion.py:START ---
from __future__ import annotations

from typing import Dict

from tycherion.application.plugins.registry import register_model
from tycherion.domain.signals.entities import IndicatorOutput, ModelDecision


@register_model(name="mean_reversion", tags={"default"})
class MeanReversion:
    def requires(self) -> set[str]:
        return {"stretch", "volatility"}

    def decide(self, indicators: Dict[str, IndicatorOutput]) -> ModelDecision:
        stretch = indicators.get("stretch") if indicators is not None else None
        z = float(stretch.features.get("z", 0.0)) if stretch else 0.0

        if z <= -2.0:
            w = min(1.0, abs(z) / 3.0)
            return ModelDecision(side="BUY", weight=w, confidence=0.6)
        if z >= 2.0:
            w = min(1.0, abs(z) / 3.0)
            return ModelDecision(side="SELL", weight=w, confidence=0.6)
        return ModelDecision(side="HOLD", weight=0.0, confidence=0.4)

--- src\tycherion\domain\signals\models\mean_reversion.py:END ---

--- src\tycherion\domain\signals\models\trend_following.py:START ---
from __future__ import annotations

from typing import Dict

from tycherion.application.plugins.registry import register_model
from tycherion.domain.signals.entities import IndicatorOutput, ModelDecision


@register_model(name="trend_following", tags={"default"})
class TrendFollowing:
    def requires(self) -> set[str]:
        return {"trend", "volatility"}

    def decide(self, indicators: Dict[str, IndicatorOutput]) -> ModelDecision:
        trend = indicators.get("trend") if indicators is not None else None
        tr = float(trend.score) if trend else 0.0

        if tr > 0.2:
            return ModelDecision(
                side="BUY",
                weight=min(1.0, 0.5 + tr * 0.5),
                confidence=0.7,
            )
        if tr < -0.2:
            return ModelDecision(
                side="SELL",
                weight=min(1.0, 0.5 + (-tr) * 0.5),
                confidence=0.7,
            )
        return ModelDecision(side="HOLD", weight=0.0, confidence=0.3)

--- src\tycherion\domain\signals\models\trend_following.py:END ---

--- src\tycherion\domain\signals\models\__init__.py:START ---


--- src\tycherion\domain\signals\models\__init__.py:END ---

--- src\tycherion\ports\account.py:START ---
from __future__ import annotations

from typing import Protocol, List

from tycherion.domain.portfolio.entities import Position


class AccountPort(Protocol):
    def is_demo(self) -> bool: ...
    def balance(self) -> float: ...
    def equity(self) -> float: ...
    def positions(self) -> List[Position]: ...

--- src\tycherion\ports\account.py:END ---

--- src\tycherion\ports\market_data.py:START ---
from __future__ import annotations
from typing import Protocol
from datetime import datetime
import pandas as pd

class MarketDataPort(Protocol):
    def get_bars(self, symbol: str, timeframe: str, start: datetime, end: datetime) -> pd.DataFrame: ...

--- src\tycherion\ports\market_data.py:END ---

--- src\tycherion\ports\trading.py:START ---
from __future__ import annotations
from dataclasses import dataclass
from typing import Protocol, Optional

@dataclass
class TradeResult:
    ok: bool
    retcode: int
    order: Optional[int]
    message: str

class TradingPort(Protocol):
    def market_buy(self, symbol: str, volume: Optional[float] = None) -> TradeResult: ...
    def market_sell(self, symbol: str, volume: Optional[float] = None) -> TradeResult: ...

--- src\tycherion\ports\trading.py:END ---

--- src\tycherion\ports\universe.py:START ---
from __future__ import annotations
from typing import Protocol, List

class UniversePort(Protocol):
    def visible_symbols(self) -> List[str]: ...
    def by_pattern(self, pattern: str) -> List[str]: ...

--- src\tycherion\ports\universe.py:END ---

--- src\tycherion\shared\config.py:START ---
from __future__ import annotations
from pydantic import BaseModel, field_validator
from typing import Optional, Any
import os, yaml
from dotenv import load_dotenv

class Trading(BaseModel):
    dry_run: bool = True
    require_demo: bool = True
    deviation_points: int = 10
    volume_mode: str = "min"     # 'min' | 'fixed'
    fixed_volume: float = 0.01

class Risk(BaseModel):
    risk_per_trade_pct: float = 0.5
    max_daily_loss_pct: float = 2.0

class MT5(BaseModel):
    terminal_path: Optional[str] = None
    server: Optional[str] = None
    login: Optional[int] = None
    password: Optional[str] = None

class RunMode(BaseModel):
    name: str = "live_multimodel"

class ScheduleCfg(BaseModel):
    run_forever: bool = False
    interval_seconds: int = 60

class CoverageCfg(BaseModel):
    source: str = "market_watch"
    symbols: list[str] = []
    pattern: str | None = None


class PipelineStageCfg(BaseModel):
    """Configuration of a single stage in the model pipeline."""

    name: str
    drop_threshold: float | None = None


class ModelsCfg(BaseModel):
    """Application-level model selection.

    `pipeline` defines an ordered list of models to run per symbol. The order
    is the order of execution. Each stage can optionally define a
    `drop_threshold` used to discard non-held symbols early.
    """

    pipeline: list[PipelineStageCfg] = []

    @field_validator("pipeline", mode="before")
    @classmethod
    def _coerce_pipeline(cls, v: Any):
        # Accept both:
        # - pipeline: ["trend_following", "mean_reversion"]
        # - pipeline: [{name: "...", drop_threshold: ...}, ...]
        if v is None:
            return []
        if isinstance(v, list):
            out: list[Any] = []
            for item in v:
                if isinstance(item, str):
                    out.append({"name": item})
                else:
                    out.append(item)
            return out
        return v


class PortfolioCfg(BaseModel):
    allocator: str = "proportional"     # plugin name
    balancer: str = "threshold"         # plugin name
    threshold_weight: float = 0.25      # only rebalance if |w| >= threshold

class ApplicationCfg(BaseModel):
    run_mode: RunMode = RunMode()
    playbook: str = "default"
    schedule: ScheduleCfg = ScheduleCfg()
    coverage: CoverageCfg = CoverageCfg()
    models: ModelsCfg = ModelsCfg()
    portfolio: PortfolioCfg = PortfolioCfg()

class AppConfig(BaseModel):
    timeframe: str
    lookback_days: int
    trading: Trading = Trading()
    risk: Risk = Risk()
    mt5: MT5 = MT5()
    application: ApplicationCfg = ApplicationCfg()

def load_config(path: str) -> AppConfig:
    load_dotenv(override=False)
    import pathlib
    p = pathlib.Path(path)
    if not p.exists():
        raise FileNotFoundError(f"Config not found: {path}")
    with open(path, "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f) or {}
    raw.setdefault("mt5", {})
    mt5_cfg = raw["mt5"] or {}

    def coalesce(yaml_val, env_val):
        return env_val if (yaml_val in (None, "", 0) and env_val not in (None, "")) else yaml_val

    env_terminal = os.getenv("MT5_TERMINAL_PATH")
    env_server   = os.getenv("MT5_SERVER")
    env_login    = os.getenv("MT5_LOGIN")
    env_pass     = os.getenv("MT5_PASSWORD")

    mt5_cfg["terminal_path"] = coalesce(mt5_cfg.get("terminal_path"), env_terminal)
    mt5_cfg["server"]        = coalesce(mt5_cfg.get("server"),        env_server)
    mt5_cfg["login"]         = coalesce(mt5_cfg.get("login"),         int(env_login) if env_login and env_login.isdigit() else None)
    mt5_cfg["password"]      = coalesce(mt5_cfg.get("password"),      env_pass)

    raw["mt5"] = mt5_cfg
    return AppConfig.model_validate(raw)

--- src\tycherion\shared\config.py:END ---

--- src\tycherion\shared\decorators.py:START ---
from __future__ import annotations
from functools import wraps
import MetaTrader5 as mt5

def demo_only(fn):
    @wraps(fn)
    def wrapper(self, *args, **kwargs):
        require = getattr(self, "require_demo", True)
        if require:
            ai = mt5.account_info()
            if not ai or ai.trade_mode != mt5.ACCOUNT_TRADE_MODE_DEMO:
                raise RuntimeError("Blocked: only allowed in DEMO account.")
        return fn(self, *args, **kwargs)
    return wrapper

def logged(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        name = fn.__qualname__
        try:
            res = fn(*args, **kwargs)
            print(f"{name}: ok -> {res}")
            return res
        except Exception as e:
            print(f"{name}: error -> {e}")
            raise
    return wrapper

--- src\tycherion\shared\decorators.py:END ---
